# -*- coding: utf-8 -*-
"""question3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16exZQF3wYBs54nACUuWHgSDxOJON0ELt
"""

from sklearn import svm
import pickle
from google.colab import drive
drive.mount('/content/drive')
import numpy as np
import os
from sklearn.metrics import confusion_matrix, classification_report

base_path = '/content/drive/My Drive/assignment2/Dataset/training/'
pkl_path = '/content/drive/My Drive/assignment2/pickle/'
test_path = '/content/drive/My Drive/assignment2/Dataset/validation/'
classes = ['zero','one','two','three','four','five','six','seven','eight','nine']
px = open(pkl_path+'mfcc/mfcc.pkl',"rb")
x_train = pickle.load(px)
px.close()
py = open(pkl_path+'mfcc/mfccy.pkl',"rb")
y_train = pickle.load(py)
py.close()
pt = open(pkl_path+'mfcc/mfccval.pkl',"rb")
x_test = pickle.load(pt)
pt.close()
pt = open(pkl_path+'mfcc/mfccyval.pkl',"rb")
y_test = pickle.load(pt)
pt.close()

x_copy = []
y_copy = []

for i in range(10017):
  x_train[i] = x_train[i].flatten()
  # print(np.array(x_train[i]).shape)
  if np.array(x_train[i]).shape == (1176,):
    x_copy.append(x_train[i].flatten())
    y_copy.append(y_train[i])
    # y_test[i[]]
# x_train = [i.flatten() for i in x_train if np.array(i).shape == (128, 92)]
# x_copy = np.nan_to_num(x_copy)
# print(len(x_train))
# print(np.array(x_train).shape, np.array(y_train).shape)
# x_copy.reshape(1, -1)

x_testc = []
y_testc = []
# print(len(x_test)- len(y_test))
for i in range(len(x_test) ):
  x_test[i] = x_test[i].flatten()
  # print(np.array(x_test[i]).shape)
  if np.array(x_test[i]).shape == (1176,):
    x_testc.append(x_test[i])
    y_testc.append(y_test[i])
# print(len(x_testc), len(y_testc),len(x_copy), len(y_copy))
x_testc = np.nan_to_num(x_testc)

    # y_test[i[]]
# x_train = [i.flatten() for i in x_train if np.array(i).shape == (128, 92)]
# x_train = np.nan_to_num(x_train)
# print(len(x_train))
# print(np.array(x_train).shape, np.array(y_train).shape)
# x_copy.reshape(1, -1)

classifier = svm.SVC(kernel='linear')
classifier.fit(x_copy, y_copy)

y_pred = classifier.predict(x_testc)

cnf = confusion_matrix(y_testc, y_pred)
print(cnf)
print(classification_report(y_testc,y_pred))



