# -*- coding: utf-8 -*-
"""Copy of question2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rKNDYtxldCzbjyO40k-cB4iXju67YlF_
"""

import numpy as np
from scipy.fftpack import dct
import os
from scipy.signal import get_window
import matplotlib.pyplot as plt
import librosa
import pickle

from google.colab import drive
drive.mount('/content/drive')

base_path = '/content/drive/My Drive/assignment2/Dataset/training/'
test_path = '/content/drive/My Drive/assignment2/Dataset/validation/'
noise_path = '/content/drive/My Drive/assignment2/Dataset/_background_noise_/'
pkl_path = '/content/drive/My Drive/assignment2/pickle/mfcc/'
classes = ['zero','one','two','three','four','five','six','seven','eight','nine']

def plot(s):
  plt.pcolormesh(s)
  plt.ylabel('Frequency [Hz]')
  plt.xlabel('Time [sec]')
  plt.show()

def pickleitout(path, obj):
  with open(path, "ab") as f:
    pickle.dump(obj, f)
    f.close()

def pad(numfs, fstep,flength, sound):
  psoundl = numfs * fstep + flength
  psound = np.append(sound, np.zeros((psoundl - len(sound))))
  return psound

def frameaudio(sound, nfft):
    flength = int(0.025 * sound[1])
    fstep = int(0.01 * sound[1] )
    numfs = int(np.ceil(float(abs(len(sound[0]) - flength)) / fstep)) 
    psound = pad(numfs, fstep,flength, sound[0])
    tile = np.tile(np.arange(0, flength), (numfs, 1)) 
    tileT = np.tile(np.arange(0, numfs * fstep, fstep), (flength, 1)).T
    hannwindow =  get_window("hann", flength, fftbins=True)
    powfs = ((1.0 / nfft) * ((abs(np.fft.rfft(psound[(tile+tileT).astype(np.int32, copy=False)] * hannwindow, 512)) ) ** 2)) 
    return powfs

def convert(samplerate, nfft):
  hztomel = np.linspace(0, (2595 * np.log10(1 + (samplerate / 2) / 700)) , 42) 
  bin = np.floor((nfft + 1) * (700 * (10 ** ( hztomel / 2595) - 1)) / samplerate)
  return bin

def getfilter(sound, bink, nfft):
  fbank = np.zeros((40, 257))
  for m in range(40):
    fmminus = int(bink[m])  
    fm = int(bink[m+1])            
    fmplus = int(bink[m + 2])   

    for k in range(fmminus, fm):
      fbank[m, k] = (k - bink[m]) / (bink[m+1] - bink[m])
    for k in range(fm, fmplus):
      fbank[m, k] = (bink[m + 2] - k) / (bink[m + 2] - bink[m + 1])
  filterbanks = np.dot(frameaudio(sound, nfft), fbank.T)
  filterbanks = 20 * np.log10( np.where(filterbanks == 0, np.finfo(float).eps, filterbanks))
  return filterbanks

def augment(path, noisepath, samplerate):
  sound = list(librosa.load(path, sr = samplerate))
  noise = list(librosa.load(noisepath, sr = samplerate))
  noiseframe  = np.random.randint(0,len(noise[0])-len(sound[0]))
  sound[0] = noise[0][noiseframe :noiseframe+len(sound[0])] *0.05 + sound[0]*0.95
  sound[0] = sound[0] / max(abs(sound[0]))
  return mfcccal(sound,samplerate)

def mfcccal(path, samplerate):
    sound = list(librosa.load(path, sr = samplerate))
    sound[0] = sound[0] / max(abs(sound[0]))
    nfft = 512
    # sound = frameaudio(sound, nfft)
    filterbanks = getfilter(sound, convert(sound[1], nfft), nfft)

    mfcc = dct(filterbanks, type=2, axis=1, norm='ortho')[:, 1 : 13]
    mfcc *= 1 + 11 * np.sin(np.pi * np.array(range(mfcc.shape[1])) /22)
    plot(mfcc)
    return mfcc

def main(path, xname, yname):
  x = []
  y = []
  count = 1
  
  for i in range(10):
    sound_path = path  + classes[i]+'/'
    # for n in os.listdir(noise_path):
    #   noisepath = noise_path+n
      for filename in os.listdir(sound_path):
        y.append(i)
        print("processing " + str(count))
        count += 1
        # s = augment(sound_path+filename, noisepath, None)
        s = mfcccal(sound_path + filename, None)
        x.append(s)
    #   break
    # break

    pickleitout(pkl_path+classes[i]+xname,x)
    pickleitout(pkl_path+classes[i]+yname,y)


  pickleitout(pkl_path+xname,x)
  pickleitout(pkl_path+yname,y)

# main(base_path, 'mfcc.pkl', 'mfccy.pkl')
main(test_path, 'mfccval.pkl', 'mfccyval.pkl')